# Chapter1 导论

- [Chapter1 导论](#chapter1-导论)
  - [1.1 典型游戏团队的结构](#11-典型游戏团队的结构)
  - [1.2 游戏是什么](#12-游戏是什么)
  - [1.3 游戏引擎是什么](#13-游戏引擎是什么)
  - [1.4 不同游戏类型的引擎差异](#14-不同游戏类型的引擎差异)
  - [1.5 游戏引擎概览](#15-游戏引擎概览)
  - [1.6 运行时引擎架构](#16-运行时引擎架构)
  - [1.7 工具及资产管道](#17-工具及资产管道)

## 1.1 典型游戏团队的结构

典型的游戏团队由: **工程师, 艺术家, 设计师, 制作人和其它管理/支持人员**组成:

1. 工程师: 负责实现软件, 有时细分为制作引擎和游戏本身的运行时程序员和制作周边工具的工具程序员. 大团队中可能有技术总监(TD)和最高级的首席技术官(CTO)负责统领全局
2. 艺术家: 负责游戏所有的视听内容, 细分出来有很多, 组织架构类似动画电影的人员分配
3. 游戏设计师: 负责游戏与玩家交互体验内容设计(例如关卡设计, 高层目标等)的职位, 其中统领全局的是游戏总监, 地位类似于电影导演, 由于游戏本身还是一个大型电子软件, 部分游戏设计师本身是工程师出身或有分配能在技术层面与工程师合作的技术性设计师. 有的团队还会聘请负责编剧的作家
4. 制作人: 很多游戏公司中制作人相当于管理进度和对外联系的经理, 一些团队不设置制作人, 也有些团队制作人兼任游戏总监.
5. 其他人员: 行政管理, 法务, 市场人员等等
6. 发行商/工作室: 负责游戏的市场策划, 发放, 分销等等

## 1.2 游戏是什么

游戏在哲学上是一种**互动体验**, 为玩家提供一连串渐进式挑战, 最终玩家通过学习而精通游戏; 而游戏在计算机科学上是一种**软实时互动基于代理的计算机模拟**.

1. 基于代理的模拟: 游戏是对现实世界的模拟, 玩家是在与游戏中模拟的对象(代理)进行互动
2. 软实时: 尽管游戏是实时模拟与玩家互动的, 但是错过刷新的时限并不会造成严重的后果. 电子游戏通常来说画面需要每秒更新30或60次, 物理运动需要更新120次, 人工智能模块需要更新至少一次, 声音库每秒也要更新60次才能确保流畅. 

## 1.3 游戏引擎是什么

从20世纪90年代中期开始, 游戏引擎这个概念逐渐形成. 游戏引擎是在软件工程层面, **将游戏的核心可复用组件剥离开以求减少后续开发成本的软件工具集**, 很多时候游戏引擎与游戏本身的分界线比较模糊. 

比较简单的区分方法是看软件的**数据流**, 引擎的大多数组件与游戏本身可以被完美剥离出来, 不会包含游戏自身的逻辑和规则, 有较强的可扩展性. 但是没有完美的游戏引擎, 到目前为止我们仍然没有完全通用的游戏引擎, 每个引擎都有自己擅长的游戏类型, 而且引擎越通用其执行性能就越低, 因此理解引擎, 对游戏来优化引擎是很重要的.

## 1.4 不同游戏类型的引擎差异

很多引擎在底层例如渲染, 输入输出等环节是通用的, 但是**高层设计依据不同游戏类型而各有侧重**.

1. 第一人称射击游戏: 非常注重技术, 对渲染质量要求很高, 对玩家运动和碰撞比较宽容, 很多都包含了多人游戏的能力
2. 平台游戏及第三人称射击游戏: 关注于角色与环境的有趣交互, 常常有复杂的摄像机系统
3. 格斗游戏: 丰富的动画, 精准的碰撞判定, 复杂的输入系统, 逼真的角色动画和模型
4. 竞速游戏: 类似第三人称射击游戏, 比较固定的赛道使得为了性能有多种远景优化技巧和对地图的分区优化执行
5. 实时策略游戏: 支持同屏显示大量对象, 设计大多在高度场地形中实现, 互动方式通常为单击
6. 大型多人在线游戏: 需要支持大量玩家在线互动且在服务器上实现持久性游玩, 有复杂的网络交互结构
7. 玩家创作类型: 需要支持玩家对游戏内容的各种改造, 例如《我的世界》

## 1.5 游戏引擎概览

记录几个常见的公用引擎, 公司内部的不开放引擎就不计了: 

1. Quake: 从《毁灭战士》开始形成的史上第一个游戏引擎家族, 代码完全开源, 尽管代码有些过时但架构非常整洁优秀, 适合学习
2. Unreal: 来自《虚幻竞技场》, 有全面易用的工具和详细的文档, 且授权费用很低
3. Source: 来自《半条命2》, 图形能力比较强, 现在比较少见
4. CryEngine: 来自《孤岛惊魂》, 图形性能非常强大
5. Unity: 强大的跨平台引擎, 工具丰富, 可以实时调试, 常见于移动端游戏
6. ORGE: 开源, 并非一个完整的游戏引擎, 主要包含了渲染模块, 架构优良易学易用

## 1.6 运行时引擎架构

![picture 2](Media/127e9cca3154acc0c1f8165d91eb60c86a88f2641c280c1e8b5bda9394bde976.png)  

游戏引擎的完整架构就是上面这张复杂的图, 和大多数软件系统一样, 游戏引擎也是按**单向依赖的软件分层**设计的, 上层依赖下层, 下层不依赖上层, 我们应该极力避免设计中出现的循环依赖.

1. 硬件层: 与不同平台硬件相关, 这部分不是重点, 我们的目标通常是平台无关的
2. 设备驱动层: 硬件厂商提供的, 不是重点.
3. 操作系统层: PC游戏系统无法全权获得主机的控制权, 所以不能极限压榨性能, 但现在游戏主机的系统也渐渐庞大, 两者差别越来越小
4. 第三方软件开发包层: 也就是编程时的各种第三方库, 例如C++的STL库, 图形编程时的OpenGL和DirectX库, 物理模拟的Havok和PhysX等等, 很多以前需要手动编程的模块如今都有现成的第三方库可使用
5. 平台独立层: 通过对底层结构的包装使得我们可以脱离具体的实现平台进行编程
6. 核心系统层: 数学库, 内存分配, 数据结构等等引擎自己编写的核心代码
7. 资源管理器: 各个引擎都有自己读写相关开发资源的管理器
8. 渲染引擎: 游戏引擎最复杂最庞大的部件, 市面上也有很多的介绍. 本书会有进一步的介绍, 计算机图形学相关的书中有更详细的介绍
9. 调试工具: 内存分析, 运行时间分析, 内置的调试用菜单等等工具, 市面上有VTune等通用工具
10. 物理系统: 运用了刚体运动学模拟的知识, Havok和PhysX是最常用的
11. 动画系统: 基于骨骼动画的蒙皮是最常用的, 其次是基于物理系统的布娃娃模拟
12. I/O系统: 处理鼠标键盘手柄等设备的输入, 进行一定的滤波和映射后反映到游戏中
13. 音频系统: 为游戏播放音频, 是常常被忽略的模块, 实际上也非常重要
14. 网络系统: 多人游戏和单人游戏有很大的区别, 一个单人游戏要支持多人游戏需要大大改变引擎设计, 但是从多人游戏改为单人游戏相对简单很多, 只要将游戏引擎作为单人游玩的特例即可
15. 游戏性系统: 常常由更高阶的编程语言驱动, 例如Unity使用的C#语言, 是游戏游玩互动本身内容的编程部分. 这个系统也非常庞大, 需要管理各种游戏对象, 事件, 脚本, 游戏内AI的交互
16. 个别游戏的专用子系统: 这部分是游戏性系统的一部分剥离, 少数系统与引擎核心联动, 例如与游玩有关的水体模拟系统

## 1.7 工具及资产管道

这部分是游戏引擎之外的资产处理工具, 例如设计三维网格模型的Maya和3dsMax, 制作音频的Sound Forge等等, 这些工具生成数据常常无法直接用到游戏中, 且常常不是实时读取的, 每个引擎都有某种形式的资产调节管道将数据读取到内存转为游戏内部的数据结构.

**世界编辑器是游戏引擎的工作核心**, 目前还没有商用的通用世界编辑器, 尽管这部分编写困难, 但却是游戏引擎极为重要的部分.

为了方便其它人员的协作, 每个引擎还会使用某种数据库去处理这些游戏资产的数据, 可以用MySQL处理, 也可以用Git等版本控制工具处理, 甚至可以直接用表格或文本来记录, 无论使用什么都需要编写对应的GUI来方便用户使用.

引擎自身的交互界面有几种实现方式:

1. 提供游戏内部的文本控制台, 通过命令在游戏执行中与引擎交互, 比较老式
2. 界面作为游戏的一份结构隐藏于游戏中同时运行, 这种结构使得Unity的实时调试功能得以简单实现, 但是会导致游戏和引擎相互耦合, 引擎某个部分的崩溃会导致游戏也发生崩溃, 而且过于复杂的结构可能降低执行效率
3. 基于网页的界面逐渐流行, 这种结构在游戏运行时捕获游戏数据并用浏览器进行监视操作, 便于维护`