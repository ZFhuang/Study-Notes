# 《Fundamentals of Computer Graphics, Fourth Edition》笔记——Chapter12 Data Structures for Graphics 图形学数据结构

本章主要介绍了图形学中常用到的数据结构，内容比较长。重点分别介绍了四个大类：网格结构(mesh structures)，空间数据结构(spatial data structures)，场景图(scene graphs)和多维镶嵌数组(tiled multidimensional arrays)。不要觉得数据结构这种运行在图形学底层的东西不重要，这本书是图形学的基础，其中所有内容都是必须非常熟悉的基础内容，每一个内容都可能在某个时候被用上。

- [《Fundamentals of Computer Graphics, Fourth Edition》笔记——Chapter12 Data Structures for Graphics 图形学数据结构](#fundamentals-of-computer-graphics-fourth-edition笔记chapter12-data-structures-for-graphics-图形学数据结构)
  - [12.1 Triangle Meshes 三角网格](#121-triangle-meshes-三角网格)
    - [12.1.1  Mesh Topology 网状拓扑](#1211--mesh-topology-网状拓扑)
    - [12.1.2  Indexed Mesh Storage 索引网格存储](#1212--indexed-mesh-storage-索引网格存储)
    - [12.1.3  Triangle Strips and Fans 三角条带和扇形](#1213--triangle-strips-and-fans-三角条带和扇形)
    - [12.1.4 Data Structures for Mesh Connectivity 为处理网格连接性的数据结构](#1214-data-structures-for-mesh-connectivity-为处理网格连接性的数据结构)
      - [The Triangle-Neighbor Structure 三角邻居结构](#the-triangle-neighbor-structure-三角邻居结构)
      - [The Winged-Edge Structure 翼边结构](#the-winged-edge-structure-翼边结构)
      - [The Half-Edge Structure 半边结构](#the-half-edge-structure-半边结构)
  - [12.2 Scene Graphs 场景图](#122-scene-graphs-场景图)
  - [12.3 Spatial Data Structures 空间数据结构](#123-spatial-data-structures-空间数据结构)
    - [12.3.1 Bounding Boxes 包围盒](#1231-bounding-boxes-包围盒)
    - [12.3.2 Hierarchical Bounding Boxes 层次包围盒](#1232-hierarchical-bounding-boxes-层次包围盒)
    - [12.3.3 Uniform Spatial Subdivision 统一空间划分](#1233-uniform-spatial-subdivision-统一空间划分)
    - [12.3.4 Axis-Aligned Binary Space Partitioning 轴对齐的二进制空间划分(BSP)](#1234-axis-aligned-binary-space-partitioning-轴对齐的二进制空间划分bsp)
  - [12.4 BSP Trees for Visibility 为优化可见性问题的BSP](#124-bsp-trees-for-visibility-为优化可见性问题的bsp)

## 12.1 Triangle Meshes 三角网格

三角网格是图形学中的基础数据结构，这部分在本书的中文版也就是第二版中着墨很少，本章介绍了很多细分的内容。之所以要有各种关于三角网格的数据结构是因为我们在处理三角网格时很多时候并不止需要顶点位置和点面关系这样的基础内容，还需要得到例如点边邻接关系，连通关系等等属性，在这种情况下如果我们仅仅使用最基础的数据结构会使得运行效率极其低下。

### 12.1.1  Mesh Topology 网状拓扑

首先要介绍在拓扑学中有一个很简单很基本的概念：流形(manifold)。流形是对表面网格的一个最基本最宽泛的要求。所谓流形，这个译名的意思是"流动的形状"，整体形状如同液体一样可以流畅改变，但是微小的局部上却是不流畅但性质相同的小平面组成。之所以要有流形这个定义是因为图形学中很多关于几何处理的代码都是基于流形性质的，非流形的处理会很麻烦。对于流形，书中给出了下面两个形象的正例和反例来说明：

下图中12.1中，左边的表面存在三个三角形共用一条边的情况，这会导致在那个边上的顶点拥有和三角面内的顶点不同的拓扑关系，因此左边的并不是流形。

![picture 1](Media/e5f693adbbea89deda99ae305427d2c967e58bd024c77f98ccf2cca5b760c4d7.png)  

下图12.2中，左图中有一个顶点被两个无法平铺的表面共享了，同样这也是干扰了边上拓扑要和三角形内相同这个条件，导致左边并不是流形。

![picture 2](Media/0503fd43bb7d861eb7a5e07ef276d1d179fc6d2eaf9e912c29d8042c3a170713.png)  

总结一下这两个例子，我们可知一个表面是流形需要满足以下两个条件：

- 每个边都被正好两个三角形共用
- 每个顶点都被一个单独且完整的三角形循环包围

但是在实际使用中，这两个流形条件常常无法满足，主要就是各种边缘情况。原始的流形定义要求了表面是封闭的，但是现实中很多表面不是封闭而是有边界的。为了处理这种情况，我们发现放宽松这个条件也不影响计算，称为有边界的流形(manifold with boundary)。同样书中举出了两个反例和正例来对比：

下图12.3中，"每个顶点都被一个单独且完整的三角形循环包围"这一条件放宽松味不需要完整循环就得到左边和中间的形式，但是如果还要进一步放松的话就是最右图的顶点连接着两个不连通的三角集合，这种情况很难被算法处理了，不再被归类在流形中。

![picture 3](Media/e6ba57514beb6dcd1f1797308c3e4b6271cf2b863ce75e65dcf088aeb05b64de.png)  

这就总结出了新的流形条件，一个表面要当有边界的流形需要满足：

- 每个边都被一个或两个三角形使用
- 每个顶点都被一个单独的边互相连通的三角形集连接(不需要包围了)

除了流形定义外，图形学中还对三角网格定义了额外的属性：

- 三角面顶点按照逆时针顺序定义的那面被认为是三角形的正面(少数标准中是反过来的)
- 一个所有网格三角面的顶点都是相同顺序的时候称为一致朝向(consistently oriented)

其中第二个属性比较特别，它表示了表面上每一对邻接三角形都是一致朝向的。而且引申出一个属性：所有非流形的网格都不是一致朝向的。而之所以我们要定义一致朝向，是因为在计算或渲染的时候我们需要按照整个表面的一致朝向属性来进行着色，渲染之类，包括计算法线方向，进行背面剔除等等等等。下图中左图是一致朝向的，右图不是：

![picture 4](Media/96ba6279b855f2555f8b5d6f5831cc1c99052ec5102ea15697c67ee81aefd5e0.png)  

但是一致朝向属性在一个很出名的情况下会被严重干扰：莫比乌斯环(Mobius band)。莫比乌斯环成功在保持所有三角形顶点排序顺序一致的情况下却让人无法决定其朝向，如下图：这个连续的表面没法分辨正面和反面。这会给算法带来很大的困扰但是幸运的是实际应用中我们几乎不会碰到这么极端的情况。

![picture 5](Media/43f2a4a33a4b56c3d19c87bd30a765ea7833df4ed1042b23983b680271ff4088.png)  

### 12.1.2  Indexed Mesh Storage 索引网格存储

如果我们要保存一个三角网格的信息，我们知道对于三角网格我们最少需要保存其顶点坐标和其面片的顶点组成，因此最容易想到的一种数据结构就是如下图的左图将三角形的顶点全部分开保存。但是很显然，这种做法会浪费大量空间因为在三角网格中很多顶点是重复出现的，并没有必要储存那么多次内容。

因此一种更实际的数据结构是索引网格存储，将顶点的共享性利用起来，一口气储存所有顶点的坐标后再对每个三角面片储存对应的索引，通过面片的索引来得到确切的三维网格。这样得到的网格称为索引三角网格(indexed triangle mesh)，结构如下图右图，对于这一系列结构建议将其理解为图或者复杂的链表。

![picture 6](Media/15826023af65ccff95aacd786633c428a8373025df4e5347f50544d9db42790a.png)  

当然这两种方法也是有权衡的，就和我们选择任何算法一样，这两个数据结构有不同的空间复杂度，我们应该通过面数和点数的占比来选择。实际使用中一般顶点数都远远大于面数(因为一个面是三个顶点组成)，因此索引方法更加常见：

- 直接保存三角形顶点信息：9*顶点数
- 索引保存：3*面数+3\*顶点数

### 12.1.3  Triangle Strips and Fans 三角条带和扇形

有些时候我们需要更加极致的空间利用，这时候就有了对特殊情况下的三角网格存储的优化，主要就是三角扇形和三角条带。

三角扇形是指优化下图形式中，所有三角形都共享一个顶点的特殊三角网格的储存。方法非常简单，所有顶点按照\[共享顶点，起点，第二个点，第三个点...\]的顺序存储即可，在使用的时候才将这种组织解开读入。这种方法不但节省了大量储存同一顶点的空间，还省去了储存面片顶点关系的索引表，为储存带来很大优势。

![picture 7](Media/afa6814da747c42ace453e21d86e603cd10c4582fbcc04fb9af6648cbd5db2c5.png)  

三角条带则是处理下图这种面片按照顺序连为一个条带的形式，这种形式的好处是我们可以找到一个序列不重复地将所有顶点串联起来，因此同样我们可以按照\[起点，第二个点，第三个点...\]的顺序存储即可，在使用的时候才将这种组织解开读入。

![picture 8](Media/da70476f8ed8b59cef1dce635e927a5b16bc89d88881b98c47c666e6d71bf354.png)  

在实际使用中这两种形式的出现机会不会太多，因此比较常见的压缩方法是按照某种算法将面片拆分为这样的三角扇的条带的形式，拆分后再按照索引表的方法储存网格，不过此时我们不用再储存各个面片的分别顶点索引而是可以以条带或扇形的顺序来储存，也能节省很多空间。还有一点就是实际使用中发现没有追求整体一个长条带的必要，很多时候能够得到由十个面片组成的条带就可以发挥出很强的储存空间优势了，长度越长优势反而提升有限，徒增麻烦。条带拆分的效果如下图：

![picture 9](Media/b497cace3c6291ee7b5eb81acfd468ee0d77d66b34c124da1e530c6a576d085e.png)  

### 12.1.4 Data Structures for Mesh Connectivity 为处理网格连接性的数据结构

很多时候为了更好地处理网格，我们需要为网格保存一些额外的信息，其中最主要的就是点-边-面之间的拓扑关系。虽然这种拓扑关系再上面的通用格式中也可以实时计算出来，但是计算代价很大，为了得到更好的计算效率最好的方法就是用额外的数据结构来储存计算好的拓扑关系。其中最最直观的方法就是用三个结构来储存其各自的索引，然后用数组分组这些结构：

- 对每个面，储存三角形对应的三条边索引和三个顶点索引
- 对每个边，储存边对应的两个顶点索引和两个三角形
- 对每个点，储存数量不定的边索引和面片索引

但是很显然这种方法空间代价很大，而且由于我们不能提前知道某顶点所对应的面和边的数量，所以如果我们想要由顶点在与顶点相关的边和面中进行搜索或处理的话，我们会发现这个过程的时间复杂度是不确定的。

#### The Triangle-Neighbor Structure 三角邻居结构

为了得到这个过程更好的查找时间复杂度，最好是常数时间的复杂度，一个好的方案是将这个结构进行改良，用间接索引的方式来储存拓扑信息：

- 对每个面，储存由边邻接的三个面索引和三个顶点索引
- 不单独储存边
- 对每个点，储存其所属的其中一个面的索引(程序决定)

这种结构称为三角邻居结构(triangle-neighbor structure)，下图可以更好地理解这种结构的构成。这种结构除了能很方便进行点到邻接结构的搜索外，还有一个好处就是可以很方便地实现对围绕一个点的邻接三角面的检索，检索的伪代码如下，主要对照下图中的绿色线，从$T_3$开始进行搜索，手动操作一次就能理解这个查找算法。

```Shell
TrianglesOfVertex(v) {  # 对于围绕的顶点v
  t = v.t # 先从顶点得到所属的面片索引
  do {
    find i such that (t.v[i] == v)  # 找到这个顶点在面片中的索引下标i
    t = t.nbr[i]  # 这个下标i代表下一个邻接的面片, 从对应的nbr数组中跳转到下一个面片
  } while (t != v.t)  # 循环直到回到起点
}
```

![picture 10](Media/4ea52765e5a2372e0a19fdbd7cb6a2007a83e9d96fff07efeab9a9cf2c04993b.png)  

这个数据结构和搜索算法保证了查找下一个面片的过程是常数时间的，但是却需要在循环中引入find操作。我们知道代码中的分支判断会比较大地影响性能，因此这个数据结构有了下面的这种优化方案：

- 对每个面，储存由边邻接的三个边索引和三个顶点索引
- 对每条边，储存其所属的其中一个面片索引和其在面片中的下标i
- 对每个点，储存其所属的其中一条边的索引

之前的结构的分支是因为我们需要查找这个顶点在面片中的索引下标i，之所以要查找下标是因为这个下标表示了这个顶点所处的边应该导向哪一个邻接的三角形。通过在新的结构中增加边的信息，现在我们可以直接从边知道下一个该搜索的面片是什么面片，在这里每个面显然只被一条边所属，所以搜索的伪代码变为下面这样：

```Shell
TrianglesOfVertex(v) {  # 对于围绕的顶点v
  {t, i} = v.e; # 从这个点得到其所属的边，边会告诉所属的三角形t和所在的下标i
  do {
    {t, i} = t.nbr[i];  # 对于现在的三角形，利用下标i我们可以检索这个边，这个边提供了该跳转的下个三角形和新的下标
    i = (i+1) mod 3;  # 为了达到围绕顶点v旋转的效果，需要对遍历的边下标进行改变
  } while (t != v.e.t); # 循环直到当前面与起点所属的面相同，也就是回到起点
}
```

这种储存方法非常紧凑，尽管多出了这么多信息但是只花费了4*顶点+6\*面片数的代价。但是使用这种结构有一个限制，需要所在的表面是流形网格，或者至少是有边界的流形网格，然后通过增加哨兵位的方式进行特殊处理。

#### The Winged-Edge Structure 翼边结构

还有一种常见的数据结构就是翼边结构(The Winged-Edge Structure)，其特点是将邻接关系都储存在网格的边上，翼边结构最大的优点在于其不仅能用在三角网格上还能用在任意形状的网格上，数据结构如下：

- 对每个面，储存其中的一个边索引
- 对每条边，储存其两个顶点，左右两个面，左边面与之连接的两条边，右边面与之连接的两条边
- 对每个点，储存其对应的一个边索引

单靠文字描述可能还不够完整，下面的图表述了翼边结构那复杂的边是如何描述一个三棱锥的

![picture 1](Media/2293869e338a2a35ad970507427174f24cc53f1c3e3cac872a308427151dc06b.png)  

翼边结构的另一大优点就是在索引邻接关系的时候非常方便，因为边储存了足够多的信息，利用这个结构我们可以在网格中自由检索。而之前的绕点检索方法伪代码如下，注意配合上图一起实践：

```Shell
EdgesOfVertex(v) {
  e = v.e;
  do {
    if (e.tail == v)  # 当于边的尾部检索时，左转
      e = e.lprev;
    else
      e = e.rprev;  # 否则右转
  } while (e != v.e);
}
```

翼边结构中显然存在很多为了加速计算而保留的信息冗余，也可以将其理解为一个多合一的双向链表。那么最简单的优化空间方法就是取出所有前向指针让翼边变为单向的，但是这样处理又会让搜索过程变得困难。而且翼边结构还有一个我们前面邻居三角结构中就遇到的问题，循环中有额外的判断存在。

#### The Half-Edge Structure 半边结构

因此又提出了半边结构(The Half-Edge Structure)来优化翼边结构。半边结构将一条边拆成了两个半边，每个半边储存用于单向检索的辅助信息和指向另一方向半边的指针，结构如下：

- 对每个面，储存其中的一个半边索引
- 对每条边，储存指向另一半边的指针和指向下一半边的指针，还有半边自己所属的那个顶点和所属的面
- 对每个点，储存其对应的一个半边索引

半边结构通过利用边的双向性在减少空间消耗的同时还达到了较好的检索效果，反向搜索的时候只要跳转到反向半边链即可，下图可以看到半边结构的邻接关系。

![picture 2](Media/2259449e5ed79686ed9d3dbf392c527668289753366399447f4289cda1476a5d.png)  

半边结构除了空间消耗上优于翼边结构，在搜索部分也优于翼边结构，半边结构无需判断当前的朝向，可以直接一连串地进行遍历。搜索的伪代码如下：

```Shell
EdgesOfVertex(v) {
  h = v.h;
  do {
    h = h.pair.next;  # 像单向链表一样不断跳转即可
  } while (h != v.h);
}
```

其中，为了区分半边的方向，很多时候我们通过将特定朝向的半边存在对应的数组下标中来隐式表示。由于半边结构性质优良，因此在需要使用网格邻接关系时，半边结构是最常用的结构。

## 12.2 Scene Graphs 场景图

图形学中我们常需要表示和储存由多个不同的三维表面按照层次组成的复杂场景，很多时候我们计算计算机动画的时候也需要用到层次结构。对于这种层次结构我们使用场景图(Scene Graphs)来保存。

场景图不难理解，其本质上是一个多叉树和一个栈的组合，场景的根结点作为树根，然后不断往树的深层扩展，每个节点除了保存了各自的属性信息外还保存了代表这个层级的仿射变换矩阵，仿射变换矩阵是因为我们常常需要对场景中的对象分层进行变换，我们知道变换矩阵链乘不能交换，因此需要用树和栈辅助。例如下图的例子，一辆放在船上的车子，车子有两个轮子：

![picture 3](Media/93a17d412b254f0df8a35a334dc58c72339965118679a6327ce27e98237effbb.png)  

我们将这个树状结构储存到文件中，每次需要渲染这个场景的时候用下面的伪代码进行。这个伪代码其实就是一个基本的深度优先搜索，核心就是用栈作为当前的保留区，利用栈中保存的矩阵链乘来渲染，使得从树顶到树底的时候顶点的变换有序且有效：

```Shell
function traverse(node)
  push(M_local) # 压入当前的变换矩阵
  draw object using composite matrix from stack # 绘制当前结点并用栈内的从顶到底矩阵链乘进行变换
  traverse(left child)  # 递归左子树
  traverse(right child) # 递归右子树
  pop() # 出栈当前结点的矩阵
```

## 12.3 Spatial Data Structures 空间数据结构

### 12.3.1 Bounding Boxes 包围盒

### 12.3.2 Hierarchical Bounding Boxes 层次包围盒

### 12.3.3 Uniform Spatial Subdivision 统一空间划分

### 12.3.4 Axis-Aligned Binary Space Partitioning 轴对齐的二进制空间划分(BSP)

## 12.4 BSP Trees for Visibility 为优化可见性问题的BSP