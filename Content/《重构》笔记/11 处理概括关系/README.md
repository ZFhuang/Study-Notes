# 11 处理概括关系

- [11 处理概括关系](#11-处理概括关系)
  - [11.1 字段上移](#111-字段上移)
  - [11.2 函数上移](#112-函数上移)
  - [11.3 构造函数本体上移](#113-构造函数本体上移)
  - [11.4 函数下移](#114-函数下移)
  - [11.5 字段下移](#115-字段下移)
  - [11.6 提炼子类](#116-提炼子类)
  - [11.7 提炼超类](#117-提炼超类)
  - [11.8 提炼接口](#118-提炼接口)
  - [11.9 折叠继承体系](#119-折叠继承体系)
  - [11.10 塑造模板函数](#1110-塑造模板函数)
  - [11.11 以委托取代继承](#1111-以委托取代继承)
  - [11.12 以继承取代委托](#1112-以继承取代委托)

## 11.1 字段上移

两个子类拥有相同字段时, 上移到基类, 注意别破坏访问控制性

## 11.2 函数上移

同11.1, 这类操作能大大减少测试难度. 如果两个函数相似但不相同, 则可以试着用模板类来优化并提取

## 11.3 构造函数本体上移

只在子类中保留构造函数有区别的部分, 然后主体通过调用基类构造来实现

## 11.4 函数下移

11.2的反面, 主要是当一些子类完全用不到某个操作时下移

## 11.5 字段下移

同11.4

## 11.6 提炼子类

当某些方法只被某些实例使用(一般是受到类型码影响)时, 提炼子类, 用继承取代

## 11.7 提炼超类

类似11.6, 将相似特性融合, 最小化重复的代码

## 11.8 提炼接口

实际上就是多继承在Java中的替代品

## 11.9 折叠继承体系

将基类和子类合并

## 11.10 塑造模板函数

就是使用模板来提炼那些操作流程相似只是类型不同的函数. Java实现起来复杂一些

## 11.11 以委托取代继承

当子类只使用到基类的一部分方法和字段时, 可以去掉继承关系, 用一个字段保存基类, 然后改为委托基类处理所需的功能. 成本是需要在基类中增加委托函数, 但一般难度不大

## 11.12 以继承取代委托

11.11的反面, 当委托了太多基类函数时, 干脆就收了吧. 但是要注意改为继承之后就无法令多个对象共享基类数据了, 因为数据共享是委托才能处理的功能, 需要权衡