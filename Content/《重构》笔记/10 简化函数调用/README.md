# 10 简化函数调用

- [10 简化函数调用](#10-简化函数调用)
  - [10.1 函数改名](#101-函数改名)
  - [10.2 添加参数](#102-添加参数)
  - [10.3 移除参数](#103-移除参数)
  - [10.4 将查询函数和修改函数分离](#104-将查询函数和修改函数分离)
  - [10.5 令函数携带参数](#105-令函数携带参数)
  - [10.6 以明确的函数取代参数](#106-以明确的函数取代参数)
  - [10.7 保持对象完整](#107-保持对象完整)
  - [10.8 以函数取代参数](#108-以函数取代参数)
  - [10.9 引入参数对象](#109-引入参数对象)
  - [10.10 移除设值函数](#1010-移除设值函数)
  - [10.11 隐藏函数](#1011-隐藏函数)
  - [10.12 以工厂函数取代构造函数](#1012-以工厂函数取代构造函数)
  - [10.13 封装向下转型](#1013-封装向下转型)
  - [10.14 以异常取代错误码](#1014-以异常取代错误码)
  - [10.15 以测试取代异常](#1015-以测试取代异常)

## 10.1 函数改名

函数名应该和注释一样清晰, 让人可以只看名字就理解函数用途

## 10.2 添加参数

过长的参数列不是好事情, 小心着点

## 10.3 移除参数

随便移除参数也很危险, 当对代码不是完全清楚时, 不要随便移除参数, 应该自创一个新的包装函数来完成需求

## 10.4 将查询函数和修改函数分离

对于任何一个有返回值的函数都不应该有看得到的副作用(内部优化查询缓存之类的操作是允许的), 应该将设值和取值功能分离. 当有返回值提供给调用者时, 必须确保返回值是可丢弃的.

多线程系统中常常有在同一个函数中完成检查和赋值操作(同步锁操作)的情况, 这种情况是允许的, 最好将这类函数清楚命名为synchronized, 然后作为设/取值函数外的第三种函数单独提供, 且其内部最好还是分别调用私有的设/取值函数组成.

## 10.5 令函数携带参数

多个命名不同但是内部行为类似的函数, 应该用参数取代混乱的命名.

## 10.6 以明确的函数取代参数

10.5的反面, 主要是当参数可选范围很小时, 提高语义的清晰度使用.

## 10.7 保持对象完整

是一个有两面性的重构, 主要是考虑传参的时侯要传数据对象还是只传对象中的某些数据项. 一般来说传整个数据对象更方便也更清晰(甚至直接传递this指针), 但是只传参可以提高函数的泛用性, 降低耦合度.

## 10.8 以函数取代参数

当某个函数的某个参数固定由另一个函数提供时, 将这个函数调用吸收到这个函数内简化参数列表. 当然如果这个提供值的函数调用依赖于调用者那我们就无法精简这个参数, 但是这种情况出现说明这几个函数可能耦合了

## 10.9 引入参数对象

同8.2将数据团包装为数据对象

## 10.10 移除设值函数

提供设值函数暗示这个字段可以随时改变, 如果你不希望这个字段在创建后改变的话就移除这种函数同时将字段设为final

## 10.11 隐藏函数

没被其它类用到的函数就设为private, 尽全力降低类的可见度

## 10.12 以工厂函数取代构造函数

同 8.14以子类取代类型码 的优化

## 10.13 封装向下转型

需要函数调用者执行向下转型的操作, 不如自己用函数封装起这个下转型操作来提高语义清晰度, 别让用户承担这些风险. 编译器能自动将子类上转型, 所以设计得当后无须提供上转型函数

## 10.14 以异常取代错误码

这个重构和执行效率有冲突, 其余没什么特别的

## 10.15 以测试取代异常

如果某个异常调用者自己就可以避免的话, 让调用者提前测试并正常返回来避免引发异常