# 6 重新组织函数

- [6 重新组织函数](#6-重新组织函数)
  - [6.1 提炼函数](#61-提炼函数)
  - [6.2 内联函数](#62-内联函数)
  - [6.3 内联临时变量](#63-内联临时变量)
  - [6.4 以查询取代临时变量](#64-以查询取代临时变量)
  - [6.5 引入解释性变量](#65-引入解释性变量)
  - [6.6 分解临时变量](#66-分解临时变量)
  - [6.7 移除对参数的赋值](#67-移除对参数的赋值)
  - [6.8 以函数对象取代函数](#68-以函数对象取代函数)
  - [6.9 替换算法](#69-替换算法)

## 6.1 提炼函数

当看见一个过长的函数或者一段需要注释才能理解用途的代码, 就会将这段代码放进一个独立函数. 只有当能够对小型函数合适地命名时, 它们才能很好地起作用. 

命名的关键在于函数名称和本体之间的语义距离. 如果提炼可以强化代码的清晰度, 那就去做, 就算函数名称比提炼出来的代码还长也无所谓. 只要新名字能更清晰地表现代码, 那就改名, 但如果想不出更好的名字, 那就别动. 

提炼的困难点在于临时变量和局部变量的处理, 最简单的方法是用参数来连接, 如果变量太多可能需要用到参数对象之类的进一步方法. 当后续代码需要用到这些变量时, 用返回值进行连接, 尽量让返回变量的命名足够清晰, 别老用result之类的模糊的词. 返回值尽量保持只有一个, 需要多个返回值很多时候就是提炼还不到位. 

## 6.2 内联函数

是“提炼函数”的反操作, 有时会遇到某些函数的内部代码和函数名称同样清晰易读. 果真如此就应该去掉这个函数, 直接使用其中的代码. 间接性可能带来帮助, 但非必要的间接性总是让人不舒服. 

另一种情况是：手上有一群组织不甚合理的函数, 可以将它们都内联到一个大型函数中, 再从中提炼出组织合理的小型函数, 也就是分层处理, 以比较大比较合理的模块进行重构会比较轻松. 

如果内联需要进行的额外操作非常多例如破坏了一体性, 破坏递归等等, 那么就不应该进行内联. 

## 6.3 内联临时变量

有一个临时变量只被一个简单表达式赋值一次, 而它妨碍了其他重构手法.  将所有对该变量的引用动作, 替换为对它赋值的那个表达式自身. 这一条和下一条一般一起出现. 

## 6.4 以查询取代临时变量

程序以一个临时变量保存某一表达式的运算结果. 将这个表达式提炼到一个独立函数中. 将这个临时变量的所有引用点替换为对新函数的调用. 此后, 新函数就可被其他函数使用, 这个重构是为了简化其他的重构步骤, 因为临时变量是重构的大敌, 驱使着我们写出更长的代码. 

有时候会遇到带有计数的临时变量, 可以尝试将循环提炼出来使得计数也被提炼到查询中. 

和其他性能问题一样现在不用管, 因为十有八九根本不会造成任何影响. 若是性能真的出了问题也可以在优化时期解决它. 代码组织良好往往就能够发现更有效的优化方案：若没有进行重构, 好的优化方案就可能失之交臂. 如果性能实在太糟糕, 要把临时变量放回去也是很容易的. 

## 6.5 引入解释性变量

这是上面两条的反操作, 但是目的是类似的. 你有一个复杂的表达式, 将该复杂表达式（或其中一部分）的结果放进一个临时变量, 以此变量名称来解释表达式用途. 尽管提取出名称更合适的函数更实用且常用, 但当提取函数非常难以进行时, 引入解释性变量就可解燃眉之急. 

## 6.6 分解临时变量

你的程序有某个临时变量被赋值超过一次(承担多种责任)，它既不是循环变量，也不被用于收集计算结果。针对每次赋值创造一个独立对应的临时变量来表达, 防止读者混乱

## 6.7 移除对参数的赋值

千万不要对参数进行赋值, 尽全力使得参数只用来表示(传进来的东西), 而对于拥有返回参数特性的语言, 除非性能瓶颈之类的考虑, 尽量不要用这种技巧. Java可以将参数标记为final来防止参数的重新赋值.

## 6.8 以函数对象取代函数

当大型函数对局部变量的使用使你无法采用ExtractMethod(110)时, 将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小型函数。例如让外部对此的调用都变为: 初始化一个对象, 然后调用对象的compute()方法. 这种优化可以使得你减少参数的传递.

## 6.9 替换算法

重构就是使得能以清晰的方式取代复杂的方式, 尽量减少重复性, 提高复用能力. 遇到一个屎山时, 先一步步对复杂函数进行分解但保留外部接口一致, 直到最后能完全替换掉复杂函数时再开始具体的算法优化.