# 7 在对象之间搬移特性

- [7 在对象之间搬移特性](#7-在对象之间搬移特性)
  - [7.1 搬移函数](#71-搬移函数)
  - [7.2 搬移字段](#72-搬移字段)
  - [7.3 提炼类](#73-提炼类)
  - [7.4 将类内联](#74-将类内联)
  - [7.5 隐藏委托关系](#75-隐藏委托关系)
  - [7.6 移除中间人](#76-移除中间人)
  - [7.7 引入外加函数](#77-引入外加函数)
  - [7.8 引入本地扩展](#78-引入本地扩展)

## 7.1 搬移函数

当有类中有一个函数对于另一个类有着更多的交流, 也就是与另一个类高度耦合, 那么将这个函数搬移到那个类中.

有时候即使移动了其他函数还是很难对眼下这个函数做出决定。这也没什么大不了的。如果真地很难做出决定，那么或许“移动这个函数与否”并不那么重要。

将源函数的代码复制到目标函数中。调整后者，使其能在新家中正常运行。如果目标函数使用了源类中的特性，你得决定如何从目标函数引用源对象。如果目标类中没有相应的引用机制，就把源对象的引用当作参数，传给新建立的目标函数。如果源函数包含异常处理，你得判断逻辑上应该由哪个类来处理这一异常。如果应该由源类来负责，就把异常处理留在原地。如果你经常要在源对象中引用目标函数，那么将源函数作为委托函数保留下来会比较简单。

如果目标函数需要太多源类特性，就得进一步重构。通常这种情况下，我会分解目标函数，并将其中一部分移回源类。

## 7.2 搬移字段

某个字段被其所驻类之外的另一个类更多地用到。在目标类新建一个字段，修改源字段的所有用户，令它们改用新字段。为了稳定搬运, 都是先在目标类建立相同的字段和对应的设/取值函数, 然后慢慢对接直到最终从源类中删除字段. 这里提醒了建立设/取值函数能使得后期需要修改引用点功能的时侯不会太困难

## 7.3 提炼类

某个类做了两个类的事情时, 适当地将其切分为两个.如果某些数据和某些函数总是一起出现，某些数据经常同时变化甚至彼此相依，这就表示你应该将它们分离出去。如果某些数据和某些函数总是一起出现，某些数据经常同时变化甚至彼此相依，这就表示你应该将它们分离出去。

分离的时侯记得先分离低层函数再搬移高层函数, 然后搬移后尽量不要建立新旧类之间的链接. 旧类一般分离后都是类似基类的存在, 可以适当缩紧访问控制.

## 7.4 将类内联

7.3的反操作, 当一个类没做多少事情时将其特性搬运到基类中.

## 7.5 隐藏委托关系

客户通过一个委托类来调用另一个对象, 在服务类上建立客户所需的所有函数，用以隐藏委托关系。这种封装使得客户可以尽可能少地了解底层原本的实现, 同时也要调整客户令其只调用委托类.

## 7.6 移除中间人

7.5的反操作, 原先的类的复杂程度已经完全不方便导致客户需要频繁调用委托类, 但是委托类并没有做多少额外的操作, 单单是不停转发源类的操作时, 直接把委托类去掉令客户调用源类更加方便

## 7.7 引入外加函数

当需要给一个无法修改的类添加功能时, 可以在客户中建立一个函数以参数形式接受目标类, 然后自己包装新的功能. 但这种做法只是权宜之计, 可以话还是修改目标类解决最好.

## 7.8 引入本地扩展

和7.7类似, 但是更进一步, 使用一个新的类包装老的类来扩展功能. 新的类必须要包含老的类的所有功能, 这种新类称为本地扩展, 必须保证在任何使用原类的地方都可以用本地扩展替代

本地扩展的实现有包装类(原类是新类的一个成员)和子类(原类是新类的基类)两种, 通常子类比较好实现, 但是需要接管原类的构造, 在原类构造后则只能通过逐元素拷贝构造来实现副本, 而包装类能做到的事情更多, 用户应该能够自然地将包装类当作原类使用.

一般来说, 本地扩展应该只添加新函数而非覆写, 防止增加用户的学习成本和防止混淆